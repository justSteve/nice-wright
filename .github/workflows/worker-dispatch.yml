name: Worker - Execute Tasks

on:
  # Triggered by orchestrator or CI retry
  repository_dispatch:
    types: 
      - worker_assign    # New task assignment
      - worker_retry     # Retry after CI failure
  
  # Manual trigger for debugging
  workflow_dispatch:
    inputs:
      task_id:
        description: 'Task ID to work on'
        required: true
        type: string
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - claim_and_execute
          - retry

permissions:
  contents: write
  pull-requests: write

env:
  META_DIR: '_meta'

jobs:
  # ============================================================
  # JOB 1: Claim and execute a task
  # ============================================================
  execute-task:
    runs-on: ubuntu-latest
    outputs:
      task_id: ${{ steps.identify.outputs.task_id }}
      branch: ${{ steps.identify.outputs.branch }}
      success: ${{ steps.execute.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Identify task
        id: identify
        run: |
          # Get task ID from dispatch or manual input
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            TASK_ID="${{ github.event.client_payload.task_id }}"
            ACTION="${{ github.event.action }}"
          else
            TASK_ID="${{ github.event.inputs.task_id }}"
            ACTION="${{ github.event.inputs.action }}"
          fi
          
          echo "task_id=$TASK_ID" >> $GITHUB_OUTPUT
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "branch=agent/$TASK_ID" >> $GITHUB_OUTPUT
          
          TASK_FILE="$META_DIR/tasks/${TASK_ID}.json"
          if [ ! -f "$TASK_FILE" ]; then
            echo "::error::Task file not found: $TASK_FILE"
            exit 1
          fi
          
          echo "task_file=$TASK_FILE" >> $GITHUB_OUTPUT
      
      - name: Check task eligibility
        id: check
        run: |
          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          ACTION="${{ steps.identify.outputs.action }}"
          
          STATUS=$(jq -r '.status' "$TASK_FILE")
          ATTEMPTS=$(jq '.attempts | length' "$TASK_FILE")
          MAX_ATTEMPTS=$(jq -r '.max_attempts' "$TASK_FILE")
          
          # Check dependencies
          DEPS=$(jq -r '.requirements.dependencies // [] | .[]' "$TASK_FILE")
          for DEP in $DEPS; do
            DEP_FILE="$META_DIR/tasks/${DEP}.json"
            if [ -f "$DEP_FILE" ]; then
              DEP_STATUS=$(jq -r '.status' "$DEP_FILE")
              if [ "$DEP_STATUS" != "complete" ]; then
                echo "::error::Dependency $DEP not complete (status: $DEP_STATUS)"
                exit 1
              fi
            fi
          done
          
          # Check attempt limits
          if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
            echo "::error::Max attempts ($MAX_ATTEMPTS) reached for task $TASK_ID"
            jq '.status = "blocked" | .blocked_reason = "max_attempts_exceeded"' "$TASK_FILE" > tmp.json && mv tmp.json "$TASK_FILE"
            exit 1
          fi
          
          # For new assignments, check status is pending
          if [ "$ACTION" = "worker_assign" ] && [ "$STATUS" != "pending" ]; then
            echo "::warning::Task $TASK_ID is not pending (status: $STATUS), skipping"
            exit 0
          fi
          
          echo "eligible=true" >> $GITHUB_OUTPUT
      
      - name: Claim task
        if: steps.check.outputs.eligible == 'true'
        run: |
          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          
          # Update task status
          jq --arg agent "worker-${{ github.run_id }}" \
             '.status = "assigned" | .assigned_to = $agent | .assigned_at = (now | todate)' \
             "$TASK_FILE" > tmp.json && mv tmp.json "$TASK_FILE"
          
          git config user.name "worker-bot"
          git config user.email "worker@bot.local"
          git add "$TASK_FILE"
          git commit -m "worker: claim task $TASK_ID"
          git push
      
      - name: Setup or checkout branch
        if: steps.check.outputs.eligible == 'true'
        run: |
          BRANCH="${{ steps.identify.outputs.branch }}"
          
          # Check if branch exists remotely
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            git fetch origin "$BRANCH"
            git checkout "$BRANCH"
            git pull origin "$BRANCH"
          else
            git checkout -b "$BRANCH"
          fi
      
      - name: Setup execution environment
        if: steps.check.outputs.eligible == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Read task requirements
        if: steps.check.outputs.eligible == 'true'
        id: requirements
        run: |
          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          
          # Extract requirements for the worker
          DESCRIPTION=$(jq -r '.requirements.description' "$TASK_FILE")
          CRITERIA=$(jq -r '.requirements.acceptance_criteria | join("\n- ")' "$TASK_FILE")
          FILES=$(jq -r '.requirements.files_to_modify // [] | join(" ")' "$TASK_FILE")
          CONTEXT=$(jq -r '.requirements.context // ""' "$TASK_FILE")
          
          # Store in environment for execution step
          echo "TASK_DESCRIPTION=$DESCRIPTION" >> $GITHUB_ENV
          echo "TASK_CRITERIA<<EOF" >> $GITHUB_ENV
          echo "$CRITERIA" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "TASK_FILES=$FILES" >> $GITHUB_ENV
          echo "TASK_CONTEXT=$CONTEXT" >> $GITHUB_ENV
      
      - name: Execute task (Mock Implementation)
        if: steps.check.outputs.eligible == 'true'
        id: execute
        run: |
          # ================================================================
          # MOCK WORKER IMPLEMENTATION
          # ================================================================
          # This mock worker generates simple, valid code files based on
          # task requirements. It demonstrates the full workflow without
          # requiring an actual LLM integration.
          #
          # To integrate a real LLM (Claude, GPT-4), replace this section
          # with API calls that:
          # 1. Send task requirements to the LLM
          # 2. Parse the response
          # 3. Write generated code to the specified files
          # ================================================================

          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          ATTEMPT_NUM=$(jq '.attempts | length + 1' "$TASK_FILE")

          echo "=== MOCK WORKER EXECUTION ==="
          echo "Task ID: $TASK_ID"
          echo "Attempt: $ATTEMPT_NUM"
          echo "Description: $TASK_DESCRIPTION"
          echo "Files to create/modify: $TASK_FILES"
          echo "=============================="

          # Parse the files to modify from task requirements
          FILES_TO_MODIFY=$(jq -r '.requirements.files_to_modify // [] | .[]' "$TASK_FILE")

          # Generate mock code for each file
          for FILE_PATH in $FILES_TO_MODIFY; do
            echo "Generating mock code for: $FILE_PATH"

            # Create directory structure if needed
            mkdir -p "$(dirname "$FILE_PATH")"

            # Determine file type and generate appropriate mock content
            case "$FILE_PATH" in
              *.ts|*.tsx)
                cat > "$FILE_PATH" << 'MOCK_TS'
          /**
           * Auto-generated by Mock Worker
           * Task: ${TASK_ID}
           * Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
           */

          export interface MockResult {
            success: boolean;
            message: string;
            timestamp: Date;
          }

          export function mockImplementation(): MockResult {
            return {
              success: true,
              message: "Mock implementation complete",
              timestamp: new Date()
            };
          }

          export default mockImplementation;
          MOCK_TS
                # Replace placeholders
                sed -i "s/\${TASK_ID}/$TASK_ID/g" "$FILE_PATH"
                ;;

              *.js|*.jsx)
                cat > "$FILE_PATH" << 'MOCK_JS'
          /**
           * Auto-generated by Mock Worker
           * Task: ${TASK_ID}
           */

          function mockImplementation() {
            return {
              success: true,
              message: "Mock implementation complete",
              timestamp: new Date()
            };
          }

          module.exports = { mockImplementation };
          MOCK_JS
                sed -i "s/\${TASK_ID}/$TASK_ID/g" "$FILE_PATH"
                ;;

              *.py)
                cat > "$FILE_PATH" << 'MOCK_PY'
          """
          Auto-generated by Mock Worker
          Task: ${TASK_ID}
          """
          from datetime import datetime
          from typing import Dict, Any


          def mock_implementation() -> Dict[str, Any]:
              """Mock implementation for testing workflow."""
              return {
                  "success": True,
                  "message": "Mock implementation complete",
                  "timestamp": datetime.utcnow().isoformat()
              }


          if __name__ == "__main__":
              result = mock_implementation()
              print(result)
          MOCK_PY
                sed -i "s/\${TASK_ID}/$TASK_ID/g" "$FILE_PATH"
                ;;

              *.json)
                cat > "$FILE_PATH" << MOCK_JSON
          {
            "_generated": {
              "task_id": "$TASK_ID",
              "worker": "mock-worker",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            },
            "data": {
              "status": "mock",
              "message": "This is mock-generated JSON"
            }
          }
          MOCK_JSON
                ;;

              *)
                # Default: create a simple text file
                cat > "$FILE_PATH" << MOCK_DEFAULT
          # Auto-generated by Mock Worker
          # Task: $TASK_ID
          # Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          This file was generated by the mock worker to test the Agentic Git workflow.
          Replace the mock worker with an actual LLM integration for real code generation.
          MOCK_DEFAULT
                ;;
            esac

            echo "Created: $FILE_PATH"
          done

          # If no specific files were requested, create a default output
          if [ -z "$FILES_TO_MODIFY" ]; then
            mkdir -p src
            cat > "src/${TASK_ID}-implementation.ts" << MOCK_DEFAULT_TS
          /**
           * Auto-generated implementation for task: $TASK_ID
           * Description: $TASK_DESCRIPTION
           * Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
           */

          export function implementation(): void {
            console.log("Task $TASK_ID implementation");
          }

          export default implementation;
          MOCK_DEFAULT_TS
            echo "Created default: src/${TASK_ID}-implementation.ts"
          fi

          # Log the execution
          mkdir -p .worker-output
          cat > ".worker-output/${TASK_ID}-attempt-${ATTEMPT_NUM}.log" << EOF
          Mock Worker Execution Log
          =========================
          Task ID: $TASK_ID
          Attempt: $ATTEMPT_NUM
          Executed at: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          Worker: worker-${{ github.run_id }}

          Task Description:
          $TASK_DESCRIPTION

          Files Generated:
          $(for f in $FILES_TO_MODIFY; do echo "  - $f"; done)

          Status: SUCCESS (mock implementation)
          EOF

          echo "success=true" >> $GITHUB_OUTPUT
          echo "Mock worker completed successfully"
      
      - name: Record attempt
        if: steps.check.outputs.eligible == 'true'
        run: |
          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          COMMIT_SHA=$(git rev-parse HEAD)
          ATTEMPT_NUM=$(jq '.attempts | length + 1' "$TASK_FILE")
          
          # Add attempt record
          jq --arg sha "$COMMIT_SHA" \
             --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --argjson num "$ATTEMPT_NUM" \
             '.status = "in_progress" | .attempts += [{
               "attempt_number": $num,
               "commit_sha": $sha,
               "ci_status": "pending",
               "timestamp": $ts
             }]' "$TASK_FILE" > tmp.json && mv tmp.json "$TASK_FILE"
      
      - name: Commit and push changes
        if: steps.check.outputs.eligible == 'true'
        run: |
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          BRANCH="${{ steps.identify.outputs.branch }}"
          
          git config user.name "worker-bot"
          git config user.email "worker@bot.local"
          
          git add -A
          git commit -m "worker($TASK_ID): implement task requirements

          Task: $TASK_ID
          Worker: worker-${{ github.run_id }}
          Attempt: $(jq '.attempts | length' $META_DIR/tasks/${TASK_ID}.json)"
          
          git push -u origin "$BRANCH"
      
      - name: Create or update PR
        if: steps.check.outputs.eligible == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TASK_ID="${{ steps.identify.outputs.task_id }}"
          BRANCH="${{ steps.identify.outputs.branch }}"
          TASK_FILE="${{ steps.identify.outputs.task_file }}"
          
          DESCRIPTION=$(jq -r '.requirements.description' "$TASK_FILE")
          CRITERIA=$(jq -r '.requirements.acceptance_criteria | map("- [ ] " + .) | join("\n")' "$TASK_FILE")
          
          # Check if PR already exists
          EXISTING_PR=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number // empty')
          
          if [ -z "$EXISTING_PR" ]; then
            gh pr create \
              --title "feat($TASK_ID): $DESCRIPTION" \
              --body "## Summary
          $DESCRIPTION

          ## Acceptance Criteria
          $CRITERIA

          ## Task Metadata
          - **Task ID:** \`$TASK_ID\`
          - **Branch:** \`$BRANCH\`
          - **Worker:** \`worker-${{ github.run_id }}\`

          ---
          _This PR is auto-managed by the Worker agent. CI must pass and Reviewer must approve before merge._" \
              --base master \
              --head "$BRANCH" \
              --label "agent-pr,automated"
            
            echo "Created new PR for task $TASK_ID"
          else
            echo "PR #$EXISTING_PR already exists for branch $BRANCH"
          fi

  # ============================================================
  # JOB 2: Handle blocked tasks
  # ============================================================
  handle-blocked:
    needs: execute-task
    if: failure()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Update task status to blocked
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TASK_ID="${{ needs.execute-task.outputs.task_id }}"
          TASK_FILE="$META_DIR/tasks/${TASK_ID}.json"
          
          if [ -f "$TASK_FILE" ]; then
            jq '.status = "blocked" | .blocked_at = (now | todate)' "$TASK_FILE" > tmp.json && mv tmp.json "$TASK_FILE"
            
            git config user.name "worker-bot"
            git config user.email "worker@bot.local"
            git add "$TASK_FILE"
            git commit -m "worker: mark task $TASK_ID as blocked"
            git push
            
            # Notify via issue comment
            ISSUE_NUM=$(gh issue list --search "Task ID: $TASK_ID" --json number --jq '.[0].number')
            if [ -n "$ISSUE_NUM" ]; then
              gh issue comment $ISSUE_NUM --body "**Task Blocked**

          The worker encountered an error and could not complete this task.
          
          - **Run ID:** ${{ github.run_id }}
          - **Run URL:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          Human intervention may be required."
            fi
          fi
